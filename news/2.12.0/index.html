<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <title>Scala 2.12.0 is now available! | The Scala Programming Language</title>
    
    <meta property="og:title" content="Scala 2.12.0 is now available!"/>
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@scala_lang"/>
    <meta name="twitter:creator" content="@scala_lang"/>
    
    <meta property="og:url" content="http://localhost:4000/news/2.12.0/"/>
    
    <meta property="og:image" content="http://localhost:4000/resources/img/scala-spiral-3d-2-toned-down.png"/>

    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <link rel="icon" type="image/png" href="/resources/favicon.ico">
    <link rel="shortcut icon" type="image/png" href="/resources/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/resources/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/resources/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/resources/favicon-16x16.png">
    <link rel="manifest" href="/resources/site.webmanifest">
    <link rel="mask-icon" href="/resources/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#15a9ce">
    <meta name="theme-color" content="#ffffff">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css"
      integrity="sha512-1sCRPdkRXhBV2PBLUdRb4tMg1w2YPf37qatUFeS7zlBy7jJI8Lf4VHwWfZZfpXtYSLy85pkm9GaYVYMfw5BC1A=="
      crossorigin="anonymous" referrerpolicy="no-referrer">

    <!-- Custom stylesheet -->
    <link href="/resources/css/unslider-dots.css" rel="stylesheet" type="text/css">
    <link href="/resources/css/unslider.css" rel="stylesheet" type="text/css">
    
    <link rel="stylesheet" href="/resources/css/highlightjs.css" type="text/css" />
    
    <link rel="stylesheet" href="/resources/css/style.css" type="text/css" />
    <link rel="stylesheet" href="/resources/css/vendor/codemirror.css" type="text/css" />
    <link rel="stylesheet" href="/resources/css/vendor/monokai.css" type="text/css" />
    <link rel="stylesheet" href="/resources/css/monospace.css" type="text/css" />

    <!-- Typekit (should stay at top of page, do not move to footer)-->
    <!--<script type="text/javascript" src="//use.typekit.net/abh3wgk.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script> -->

    <!-- Atom feeds -->
    <link rel="alternate" type="application/atom+xml" title="News Feed" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Feed" href="/feed/blog.xml" />


  </head>
  <body>

<div class="navigation-fade-screen"></div>

<header id="site-header">
	<div class="wrap">
		<nav class="navigation" role="menu">
			<a href="/" class="navigation-bdand">
				<img src="/resources/img/frontpage/scala-logo-white@2x.png" alt="">
			</a>
			<div class="navigation-panel-button">
				<i class="fa fa-bars"></i>
			</div>
			<ul class="navigation-menu">
				
				    <li class="navigation-menu-item">
                    <a href="https://docs.scala-lang.org" >Learn</a>
				    </li>
				
				    <li class="navigation-menu-item">
                    <a href="/download/" >Install</a>
				    </li>
				
				    <li class="navigation-menu-item">
                    <a href="https://scastie.scala-lang.org" >Playground</a>
				    </li>
				
				    <li class="navigation-menu-item">
                    <a href="https://index.scala-lang.org" >Find a Library</a>
				    </li>
				
				    <li class="navigation-menu-item">
                    <a href="/community/" >Community</a>
				    </li>
				
				    <li class="navigation-menu-item">
                    <a href="/blog/" >Blog</a>
				    </li>
				
			</ul>
		</nav>
	</div>
</header>


<main id="inner-main">

	<!-- Title -->
	<section class="title-page">
		<div class="wrap">
			<h1>Scala 2.12.0 is now available!</h1>
		</div>
	</section>

	
	<!-- Main content -->
<section class="content">
	<div class="wrap">
		<div class="content-primary">
			<div class="inner-box">
				<div class="blog-detail-head">
					<div>
						<p>Thursday 3 November 2016</p>
						<p></p>
					</div>
					
					<ul class="tag-list">
						
					</ul>
					
					</div>
					<div class="filter-tag">ANNOUNCEMENT</div>
					<!-- <h2><a href="/news/2.12.0/">Scala 2.12.0 is now available!</a></h2> -->
					<p>We are very happy to announce the availability of Scala 2.12.0!</p>

<h2 id="headline-features">Headline features</h2>

<p>The Scala 2.12 compiler has been completely overhauled to make use of the new VM features available in Java 8:</p>

<ul>
  <li>A trait <a href="#traits-compile-to-interfaces">compiles directly to an interface</a> with default methods. This improves binary compatibility and Java interoperability.</li>
  <li>Scala and Java 8 interop is also improved for functional code, as methods that take functions can easily be called in both directions using lambda syntax. The  <code class="language-plaintext highlighter-rouge">FunctionN</code> classes in Scala’s standard library are now Single Abstract Method (SAM) types, and all <a href="#lambda-syntax-for-sam-types">SAM types</a> are treated uniformly – from type checking through code generation. No class file is generated for a lambda; <code class="language-plaintext highlighter-rouge">invokedynamic</code> is used instead.</li>
</ul>

<p>This release ships with a powerful <a href="#new-optimizer">new optimizer</a>:</p>

<ul>
  <li>Inlining: many more (effectively) final methods, including those defined in objects and traits, are now inlined.</li>
  <li>Closure allocations, dead code, and box/unbox pairs are eliminated more often.</li>
</ul>

<p>For additional features, read on.</p>

<h2 id="compatibility">Compatibility</h2>

<p>Although Scala 2.11 and 2.12 are mostly source compatible to facilitate cross-building, they are not <em>binary</em> compatible.  This allows us to keep improving the Scala compiler and standard library.</p>

<p>All 2.12.x releases will be fully binary compatible with 2.12.0, in according with <a href="https://docs.scala-lang.org/overviews/core/binary-compatibility-of-scala-releases.html">the policy</a> we have followed since 2.10.</p>

<p>The <a href="https://github.com/scala/make-release-notes/blob/2.12.x/projects-2.12.md">list of open-source libraries</a> released for Scala 2.12 is growing quickly!</p>

<p>This release is identical to 2.12.0-RC2.</p>

<h2 id="coming-soon">Coming soon</h2>

<p>Our <a href="https://github.com/scala/scala/milestones">roadmap</a> lists the following upcoming releases for 2016:</p>

<ul>
  <li>2.12.1 will be out shortly (by the end of November) to address some known (but rare) issues in 2.12.0.</li>
  <li>2.11.9 will be the last planned 2.11.x release (due by mid December)</li>
</ul>

<p>In the next few weeks, we at Lightbend will share our plans for Scala 2.13.</p>

<h2 id="known-issues">Known issues</h2>

<p>There are some <a href="https://issues.scala-lang.org/browse/SI-10009?jql=project%20%3D%20SI%20AND%20affectedVersion%20%3D%20%22Scala%202.12.0%22">known issues</a> with this release that <a href="https://github.com/scala/scala/pulls?q=is%3Apr+milestone%3A2.12.1+label%3Arelease-notes">will be resolved</a> in 2.12.1, due later in November.</p>

<p>The heavy use of default methods for compiling traits caused some performance regressions in the startup time of Scala applications. Note that steady-state performance is not affected according to our measurements.</p>

<p>The regression was mitigated 2.12.0-RC2 (and the final release) by generating forwarder methods in classes that inherit concrete methods from traits, which unfortunately <a href="https://github.com/scala/scala/pull/5429">increases bytecode size</a> while improving JVM startup performance.</p>

<p>Please let us know if you notice any performance regressions. We will continue to tweak the bytecode during the 2.12.x cycle to get the best performance out of the JVM.</p>

<p>We hope to address the following in a later 2.12.x release:</p>

<ul>
  <li><a href="https://issues.scala-lang.org/browse/SI-9824">SI-9824</a>: Parallel collections are prone to deadlock in the REPL and in object initializers.</li>
</ul>

<h2 id="obtaining-scala">Obtaining Scala</h2>

<h3 id="java-8-runtime">Java 8 runtime</h3>

<p>Install a recent build of the Java 8 Platform, such as <a href="https://openjdk.java.net/install/">OpenJDK</a> or <a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html">Oracle Java</a>. Any Java 8 compliant runtime will do (but note that Oracle versions before 8u102 have a known issue that <a href="https://issues.scala-lang.org/browse/SI-9828">affects Scala</a>).</p>

<p>We are planning to add (some) support for Java 9 in the near future. Full Java 9 support will be part of the 2.13 roadmap discussions.</p>

<h3 id="build-tool">Build tool</h3>

<p>We recommend using <a href="https://www.scala-sbt.org/download.html">sbt 0.13.13</a>. Simply bump the <code class="language-plaintext highlighter-rouge">scalaVersion</code> setting in your existing project, or start a new project using <code class="language-plaintext highlighter-rouge">sbt new scala/scala-seed.g8</code>. We strongly recommend upgrading to sbt 0.13.13 for <a href="https://github.com/sbt/sbt/pull/2705">templating support using the new command</a>, <a href="https://github.com/sbt/sbt/pull/2754">faster compilation</a>, and <a href="https://www.scala-sbt.org/0.13/docs/sbt-0.13-Tech-Previews.html#sbt+0.13.13">much more</a>.</p>

<p>Please head over to the <a href="https://github.com/scala/scala-seed.g8">scala-seed repo</a> to extend this <a href="https://github.com/foundweekends/giter8">giter8 template</a> with an example of your favorite 2.12 feature!</p>

<p>Scala also works with <a href="https://docs.scala-lang.org/tutorials/scala-with-maven.html">Maven</a>, <a href="https://docs.gradle.org/current/userguide/scala_plugin.html">Gradle</a>, and Ant.</p>

<p>You can also download a distribution from <a href="https://scala-lang.org/download/2.12.0.html">scala-lang.org</a>, or obtain the JARs yourself from <a href="https://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.scala-lang%22%20AND%20v%3A%222.12.0%22">Maven Central</a>.</p>

<h2 id="contributors">Contributors</h2>

<p>A big thank you to everyone who’s helped improve Scala by reporting bugs, improving our documentation, kindly helping others on forums and at meetups, and submitting and reviewing pull requests! You are all magnificent.</p>

<p>Scala 2.12.0 is the result of merging over <a href="https://github.com/scala/scala/pulls?utf8=%E2%9C%93&amp;q=is%3Amerged%20label%3A2.12%20">500 pull requests</a> out of about <a href="https://github.com/scala/scala/pulls?utf8=%E2%9C%93&amp;q=is%3Apr%20label%3A2.12%20">600 received PRs</a>. The <a href="https://github.com/scala/scala/graphs/contributors?from=2014-11-01&amp;to=2016-10-29&amp;type=c">contributions to 2.12.x</a> over the last 2 years <a href="https://docs.google.com/spreadsheets/d/16zVViCpJEZn_x2RlYFh-xAOiHJG3SrYYpfetRr5cu_Y/edit#gid=912693440">were split</a> 64/32/4 between the Scala team at Lightbend (<a href="https://github.com/lrytz">lrytz</a>, <a href="https://github.com/retronym">retronym</a>, <a href="https://github.com/adriaanm">adriaanm</a>, <a href="https://github.com/SethTisue">SethTisue</a>, <a href="https://github.com/szeiger">szeiger</a>), the community, and EPFL.</p>

<p>The new encodings of traits, lambdas, and lazy vals were developed in fruitful collaboration with the Dotty team at EPFL.</p>

<p>The new compiler back end and the new optimizer are based on earlier work by Miguel Garcia at EPFL.</p>

<h2 id="scala-212-overview">Scala 2.12 overview</h2>

<p>Scala 2.12 is all about making optimal use of Java 8’s new features. Thus, it generates code that requires a Java 8 runtime.</p>

<ul>
  <li>Traits (<a href="https://github.com/scala/scala/pull/5003">#5003</a>) and functions are compiled to their Java 8 equivalents. The compiler no longer generates trait implementation classes (<code class="language-plaintext highlighter-rouge">T$class.class</code>) and anonymous function classes (<code class="language-plaintext highlighter-rouge">C$$anonfun$1.class</code>).</li>
  <li>We treat Single Abstract Method types and Scala’s built-in function types uniformly from type checking to the back end (<a href="https://github.com/scala/scala/pull/4971">#4971</a>).</li>
  <li>We use <code class="language-plaintext highlighter-rouge">invokedynamic</code> for compiling functions. It also now provides a more natural encoding of other language features (<a href="https://github.com/scala/scala/pull/4896">#4896</a>).</li>
  <li>We’ve standardized on the GenBCode back end (<a href="https://github.com/scala/scala/pull/4814">#4814</a>, <a href="https://github.com/scala/scala/pull/4838">#4838</a>) and the flat classpath implementation is now the default (<a href="https://github.com/scala/scala/pull/5057">#5057</a>).</li>
  <li>The optimizer has been completely overhauled for 2.12.</li>
</ul>

<p>The new encodings for traits and lambdas lead to significantly smaller JAR files. For example, for ScalaTest 3.0.0, the jar size dropped from 9.9M to 6.7M.</p>

<p>Except for the breaking changes listed below, code that compiles on 2.11.x without deprecation warnings should compile on 2.12.x, unless you use experimental APIs such as reflection.  If you find incompatibilities that are not <a href="#breaking-changes">listed below</a>, please <a href="https://issues.scala-lang.org">file an issue</a>.</p>

<p>Thanks to source compatibility, cross-building is a one-line change to most sbt builds. Where needed, sbt provides support for <a href="https://www.scala-sbt.org/0.13/docs/sbt-0.13-Tech-Previews.html#Cross-version+support+for+Scala+sources">version-specific source folders</a> out of the box.</p>

<h3 id="new-language-features">New language features</h3>

<p>The next sections introduce new features and breaking changes in Scala 2.12 in more detail. To understand more technicalities and review past discussions, you can also take a look at the full list of <a href="https://github.com/scala/scala/pulls?utf8=%E2%9C%93&amp;q=%20is%3Amerged%20label%3A2.12%20label%3Arelease-notes%20">noteworthy pull request</a> that went into this release.</p>

<h4 id="traits-compile-to-interfaces">Traits compile to interfaces</h4>

<p>Because Java 8 allows concrete methods in interfaces, Scala 2.12 is able to compile a trait to a single interface classfile. Before, a trait was represented as an interface and a class that held the method implementations (<code class="language-plaintext highlighter-rouge">T$class.class</code>).</p>

<p>Additional magic is still involved, so care must be taken if a trait is meant to be implemented in Java. Briefly, if a trait does any of the following, its subclasses require synthetic code:</p>

<ul>
  <li>defining fields (<code class="language-plaintext highlighter-rouge">val</code> or <code class="language-plaintext highlighter-rouge">var</code>, but a constant is ok – <code class="language-plaintext highlighter-rouge">final val</code> without result type)</li>
  <li>calling super</li>
  <li>initializer statements in the body</li>
  <li>extending a class</li>
  <li>relying on linearization to find implementations in the right supertrait</li>
</ul>

<h4 id="lambda-syntax-for-sam-types">Lambda syntax for SAM types</h4>

<p>The Scala 2.12 type checker accepts a function literal as a valid expression for any Single Abstract Method (SAM) type, in addition to the <code class="language-plaintext highlighter-rouge">FunctionN</code> types from standard library. This improves the experience of using libraries written for Java 8 from Scala code. Here is a REPL example using <code class="language-plaintext highlighter-rouge">java.lang.Runnable</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val r: Runnable = () =&gt; println("Run!")
r: Runnable = $$Lambda$1073/754978432@7cf283e1

scala&gt; r.run()
Run!
</code></pre></div></div>

<p>Note that only lambda expressions are converted to SAM type instances, not arbitrary expressions of <code class="language-plaintext highlighter-rouge">FunctionN</code> type:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val f = () =&gt; println("Faster!")

scala&gt; val fasterRunnable: Runnable = f
&lt;console&gt;:12: error: type mismatch;
 found   : () =&gt; Unit
 required: Runnable
</code></pre></div></div>

<p>The language specification has the <a href="https://www.scala-lang.org/files/archive/spec/2.12/06-expressions.html#sam-conversion">full list of requirements for SAM conversion</a>.</p>

<p>With the use of default methods, Scala’s built-in <code class="language-plaintext highlighter-rouge">FunctionN</code> traits are compiled to SAM interfaces. This allows creating Scala functions from Java using Java’s own lambda syntax:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class A {
  scala.Function1&lt;String, String&gt; f = s -&gt; s.trim();
}
</code></pre></div></div>

<p>Specialized function classes are also SAM interfaces and can be found in the package <code class="language-plaintext highlighter-rouge">scala.runtime.java8</code>.</p>

<p>Thanks to an improvement in type checking, the parameter type in a lambda expression can be omitted even when the invoked method is overloaded.  See <a href="https://github.com/scala/scala/pull/5307">#5307</a> for details. In the following example, the compiler infers parameter type <code class="language-plaintext highlighter-rouge">Int</code> for the lambda:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; trait MyFun { def apply(x: Int): String }

scala&gt; object T {
     |   def m(f: Int =&gt; String) = 0
     |   def m(f: MyFun) = 1
     | }

scala&gt; T.m(x =&gt; x.toString)
res0: Int = 0
</code></pre></div></div>

<p>Note that though both methods are applicable, overloading resolution selects the one with the <code class="language-plaintext highlighter-rouge">Function1</code> argument type, as <a href="#sam-conversion-in-overloading-resolution">explained in more detail below</a>.</p>

<h4 id="java-8-style-bytecode-for-lambdas">Java 8-style bytecode for lambdas</h4>

<p>Scala 2.12 emits bytecode for functions in the same style as Java 8, whether they target a <code class="language-plaintext highlighter-rouge">FunctionN</code> class from the standard library or a user-defined Single Abstract Method (SAM) type.</p>

<p>For each lambda the compiler generates a method containing the lambda body, and emits an <code class="language-plaintext highlighter-rouge">invokedynamic</code> that will spin up a lightweight class for this closure using the JDK’s <code class="language-plaintext highlighter-rouge">LambdaMetaFactory</code>. Note that in the following situations, an anonymous function class is still synthesized at compile time:</p>

<ul>
  <li>If the SAM type is not a simple interface, for example an abstract class or a trait with a field definition (see <a href="https://github.com/scala/scala/pull/4971">#4971</a>)</li>
  <li>If the abstract method is specialized – except for <code class="language-plaintext highlighter-rouge">scala.FunctionN</code>, whose specialized variants can be instantiated using <code class="language-plaintext highlighter-rouge">LambdaMetaFactory</code> (see <a href="https://github.com/scala/scala/pull/4971">#4971</a>)</li>
  <li>If the function literal is defined in a constructor or super call (<a href="https://github.com/scala/scala/pull/3616">#3616</a>)</li>
</ul>

<p>Compared to Scala 2.11, the new scheme has the advantage that, in most cases, the compiler does not need to generate an anonymous class for each closure.</p>

<p>Our backend support for <code class="language-plaintext highlighter-rouge">invokedynamic</code> is also available to macro authors, as shown in <a href="https://github.com/scala/scala/blob/v2.12.0/test/files/run/indy-via-macro-with-dynamic-args/macro_1.scala">this test case</a>.</p>

<h4 id="partial-unification-for-type-constructor-inference">Partial unification for type constructor inference</h4>

<p>Compiling with <code class="language-plaintext highlighter-rouge">-Ypartial-unification</code> improves type constructor inference with support for partial unification, fixing the notorious <a href="https://issues.scala-lang.org/browse/SI-2712">SI-2712</a>. Thank you, <a href="https://github.com/milessabin">Miles Sabin</a> for contributing <a href="https://github.com/scala/scala/pull/5102">your implementation</a> (and <a href="https://github.com/scala/scala/pull/5343">backporting to 2.11.9</a>)!</p>

<p>Also, hat tip to Daniel Spiewak for <a href="https://gist.github.com/djspiewak/7a81a395c461fd3a09a6941d4cd040f2">a great explanation of this feature</a>.</p>

<p>We recommend enabling this with <code class="language-plaintext highlighter-rouge">-Ypartial-unification</code> rather than <code class="language-plaintext highlighter-rouge">-Xexperimental</code>, as the latter enables some surprising features that will not ship with a future release of Scala.</p>

<h4 id="new-representation-and-locking-scope-for-local-lazy-vals">New representation and locking scope for local lazy vals</h4>

<p>Local lazy vals and objects, i.e., those defined in methods, now use a more efficient representation (implemented in <a href="https://github.com/scala/scala/pull/5294">#5294</a> and <a href="https://github.com/scala/scala/pull/5374">#5374</a>).</p>

<p>In Scala 2.11, a local lazy val was encoded using two heap-allocated objects (one for the value, a second for the initialized flag). Initialization was synchronized on the enclosing class instance.</p>

<p>In 2.12, with the new <a href="#java-8-style-bytecode-for-lambdas">representation for lambdas</a>, which emits the lambda body as a method in the enclosing class, new deadlocks can arise for lazy vals or objects defined in the lambda body.</p>

<p>This has been fixed by creating a single heap-allocated object that is used for init locking and holds both the value and the initialized flag. (A similar implementation already existed in Dotty.)</p>

<h4 id="better-type-inference-for-scalajs">Better type inference for Scala.js</h4>

<p>The <a href="#lambda-syntax-for-sam-types">improved type inference for lambda parameters</a> also benefits <code class="language-plaintext highlighter-rouge">js.Function</code>s. For example, you can now write:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dom.window.requestAnimationFrame { now =&gt; // inferred as Double
  ...
}
</code></pre></div></div>

<p>without having to specify <code class="language-plaintext highlighter-rouge">(now: Double)</code> explicitly.</p>

<p>In a similar spirit, the <a href="#inferred-types-for-fields">new inference for overriding <code class="language-plaintext highlighter-rouge">val</code>s</a> allows to more easily implement Scala.js-defined JS traits with anonymous objects. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@ScalaJSDefined
trait SomeOptions extends js.Object {
  val width: Double | String // e.g., "300px"
}
val options = new SomeOptions {
  // implicitly converted from Int to the inferred Double | String
  val width = 200
}
</code></pre></div></div>

<h3 id="tooling-improvements">Tooling improvements</h3>

<h4 id="new-back-end">New back end</h4>

<p>Scala 2.12 standardizes on the “GenBCode” back end, which emits code more quickly because it directly generates bytecode from Scala compiler trees. (The old back end used an intermediate representation.) The old back ends (GenASM and GenIcode) have been removed (<a href="https://github.com/scala/scala/pull/4814">#4814</a>, <a href="https://github.com/scala/scala/pull/4838">#4838</a>).</p>

<h4 id="new-optimizer">New optimizer</h4>

<p>The GenBCode back end includes a new inliner and bytecode optimizer. The optimizer is configured using the <code class="language-plaintext highlighter-rouge">-opt</code> compiler option. By default it only removes unreachable code within a method. Check <code class="language-plaintext highlighter-rouge">-opt:help</code> to see the list of available options for the optimizer.</p>

<p>The following optimizations are available:</p>

<ul>
  <li>Inlining final methods, including methods defined in objects and final methods defined in traits</li>
  <li>If a closure is allocated and invoked within the same method, the closure invocation is replaced by an invocations of the corresponding lambda body method</li>
  <li>Dead code elimination and a small number of cleanup optimizations</li>
  <li>Box/unbox elimination <a href="https://github.com/scala/scala/pull/4858">#4858</a>: primitive boxes and tuples that are created and used within some method without escaping are eliminated.</li>
</ul>

<p>For example, the following code</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def f(a: Int, b: Boolean) = (a, b) match {
  case (0, true) =&gt; -1
  case _ if a &lt; 0 =&gt; -a
  case _ =&gt; a
}
</code></pre></div></div>

<p>produces, when compiled with <code class="language-plaintext highlighter-rouge">-opt:l:method</code>, the following bytecode (decompiled using <a href="https://www.benf.org/other/cfr/">cfr</a>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public int f(int a, boolean b) {
  int n = 0 == a &amp;&amp; true == b ? -1 : (a &lt; 0 ? - a : a);
  return n;
}
</code></pre></div></div>

<p>The optimizer supports inlining (disabled by default). With <code class="language-plaintext highlighter-rouge">-opt:l:project</code> code from source files currently being compiled is inlined, while <code class="language-plaintext highlighter-rouge">-opt:l:classpath</code> enables inlining code from libraries on the compiler’s classpath. Other than methods marked <a href="https://www.scala-lang.org/files/archive/api/2.12.0/scala/inline.html"><code class="language-plaintext highlighter-rouge">@inline</code></a>, higher-order methods are inlined if the function argument is a lambda, or a parameter of the caller.</p>

<p>Note that:</p>

<ul>
  <li>We recommend enabling inlining only in production builds, as sbt’s incremental compilation does not track dependencies introduced by inlining.</li>
  <li>When inlining code from the classpath, you must ensure that all dependencies have exactly the same versions at compile time and run time.</li>
  <li>If you are building a library to publish on Maven Central, you should not inline code from dependencies. Users of your library might have different versions of those dependencies on the classpath, which breaks binary compatibility.</li>
</ul>

<p>The Scala distribution is built using <code class="language-plaintext highlighter-rouge">-opt:l:classpath</code>, which improves the performance of the Scala compiler by roughly 5% (hot and cold, measured using our <a href="https://github.com/scala/compiler-benchmark/blob/master/compilation/src/main/scala/scala/tools/nsc/ScalacBenchmark.scala">JMH-based benchmark suite</a>) compared to a non-optimized build.</p>

<h4 id="scaladoc-look-and-feel-overhauled">Scaladoc look-and-feel overhauled</h4>

<p>Scaladoc’s output is now more attractive, more modern, and easier to use. Take a look at the <a href="https://www.scala-lang.org/api/2.12.0">Scala Standard Library API</a>.</p>

<p>Thanks, <a href="https://github.com/felixmulder">Felix Mulder</a>, for leading this effort.</p>

<h4 id="scaladoc-can-be-used-to-document-java-sources">Scaladoc can be used to document Java sources</h4>

<p>This fix for <a href="https://issues.scala-lang.org/browse/SI-4826">SI-4826</a> simplifies generating comprehensive documentation for projects with both Scala and Java sources. Thank you for your contribution, <a href="https://github.com/jodersky">Jakob Odersky</a>!</p>

<p>This feature is enabled by default, but can be disabled with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scalacOptions in (Compile, doc) += "-no-java-comments"
</code></pre></div></div>

<p>Some projects with very large Javadoc comments may run into a stack overflow in the Javadoc scanner, which <a href="https://github.com/scala/scala/pull/5469">will be fixed in 2.12.1</a>.</p>

<h4 id="scala-shell-repl">Scala shell (<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>)</h4>

<p>Scala’s interactive shell ships with several spiffy improvements. To try it out, launch it from the command line with the <code class="language-plaintext highlighter-rouge">scala</code> script or in sbt using the <code class="language-plaintext highlighter-rouge">console</code> task. If you like color (who doesn’t!), use <code class="language-plaintext highlighter-rouge">scala -Dscala.color</code> instead, until <a href="https://github.com/scala/scala-dev/issues/256">it’s turned on by default</a>.</p>

<p>Since 2.11.8, the REPL uses the same tab completion logic as ScalaIDE and ENSIME, which greatly improves the experience. Check out <a href="https://github.com/scala/scala/pull/4725">PR 4725</a> for some tips and tricks.</p>

<h4 id="sbt-builds-scala">sbt builds Scala</h4>

<p>Scala itself is now completely built, tested and published with sbt!</p>

<p>This makes it easier to get started hacking on the compiler and standard library. All you need on your machine is JDK 8 and sbt - no ant, no environment variables to set, no shell scripts to run. You can <a href="https://github.com/scala/scala/blob/2.12.x/README.md#using-the-sbt-build">build, use, test and publish</a> Scala like any other sbt-based project.</p>

<p>Due to Scala’s bootstrapped nature, IntelliJ cannot yet import our sbt build directly. Use the <code class="language-plaintext highlighter-rouge">intellij</code> task instead to generate suitable project files.</p>

<h3 id="library-improvements">Library improvements</h3>

<h4 id="either-is-now-right-biased">Either is now right-biased</h4>

<p><code class="language-plaintext highlighter-rouge">Either</code> now supports operations like <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">flatMap</code>, <code class="language-plaintext highlighter-rouge">contains</code>, <code class="language-plaintext highlighter-rouge">toOption</code>, and so forth, which operate on the right-hand side. The <code class="language-plaintext highlighter-rouge">.left</code> and <code class="language-plaintext highlighter-rouge">.right</code> methods may be deprecated in favor of <code class="language-plaintext highlighter-rouge">.swap</code> in a later release.
The changes are source-compatible with existing code (except in the presence of conflicting extension methods).</p>

<p>This change has allowed other libraries, such as <a href="https://typelevel.org/cats/">cats</a> to standardize on <code class="language-plaintext highlighter-rouge">Either</code>.</p>

<p>Thanks, <a href="https://github.com/soc">Simon Ochsenreither</a>, for this contribution.</p>

<h4 id="futures-improved">Futures improved</h4>

<p>A number of improvements to <code class="language-plaintext highlighter-rouge">scala.concurrent.Future</code> were made for Scala 2.12. This <a href="https://github.com/viktorklang/blog">blog post series</a> by Viktor Klang explores them in detail.</p>

<h4 id="scala-java8-compat">scala-java8-compat</h4>

<p>The <a href="https://github.com/scala/scala-java8-compat">Java 8 compatibility module for Scala</a> has received an overhaul for Scala 2.12. Even though interoperability of Java 8 SAMs and Scala functions is now baked into the language, this module provides additional convenience for working with Java 8 SAMs. Java 8 streams support was also added during the development cycle of Scala 2.12. Releases are available for both Scala 2.11 and Scala 2.12.</p>

<h3 id="other-changes-and-deprecations">Other changes and deprecations</h3>

<ul>
  <li>For comprehension desugaring requires <code class="language-plaintext highlighter-rouge">withFilter</code> now, never falls back to <code class="language-plaintext highlighter-rouge">filter</code> (<a href="https://github.com/scala/scala/pull/5252">#5252</a>)</li>
  <li>A <a href="https://www.scala-lang.org/files/archive/api/2.12.0/scala/collection/mutable/TreeMap.html">mutable TreeMap</a> implementation was added (<a href="https://github.com/scala/scala/pull/4504">#4504</a>).</li>
  <li><a href="https://www.scala-lang.org/files/archive/api/2.12.0/scala/collection/immutable/ListSet.html">ListSet</a> and <a href="https://www.scala-lang.org/files/archive/api/2.12.0/scala/collection/immutable/ListMap.html">ListMap</a> now ensure insertion-order traversal (in 2.11.x, traversal was in reverse order), and their performance has been improved (<a href="https://github.com/scala/scala/pull/5103">#5103</a>).</li>
  <li>The <a href="https://www.scala-lang.org/files/archive/api/2.12.0/scala/deprecatedInheritance.html"><code class="language-plaintext highlighter-rouge">@deprecatedInheritance</code></a> and <a href="https://www.scala-lang.org/files/archive/api/2.12.0/scala/deprecatedOverriding.html"><code class="language-plaintext highlighter-rouge">@deprecatedOverriding</code></a> are now public and available to library authors.</li>
  <li>The <code class="language-plaintext highlighter-rouge">@hideImplicitConversion</code> Scaladoc annotation allows customizing which implicit conversions are hidden (<a href="https://github.com/scala/scala/pull/4952">#4952</a>).</li>
  <li>The <code class="language-plaintext highlighter-rouge">@shortDescription</code> Scaladoc annotation customizes the method summary on entity pages (<a href="https://github.com/scala/scala/pull/4991">#4991</a>).</li>
  <li>JavaConversions, providing implicit conversions between Scala and Java collection types, has been deprecated. We recommend using <a href="https://www.scala-lang.org/files/archive/api/2.12.0/scala/collection/JavaConverters$.html">JavaConverters</a> and explicit <code class="language-plaintext highlighter-rouge">.asJava</code> / <code class="language-plaintext highlighter-rouge">.asScala</code> conversions.</li>
  <li>Eta-expansion (conversion of a method to a function value) of zero-args methods has been deprecated, as this can lead to surprising behavior (<a href="https://github.com/scala/scala/pull/5327">#5327</a>).</li>
  <li>The Scala library is now <a href="https://github.com/scala/scala/pull/4443">free</a> of <a href="https://github.com/scala/scala/pull/4712">references</a> to <code class="language-plaintext highlighter-rouge">sun.misc.Unsafe</code>, and <a href="https://github.com/scala/scala/pull/4629">no longer ships</a> with a fork of the forkjoin library.</li>
  <li>Exhaustiveness analysis in the pattern matcher has been improved (<a href="https://github.com/scala/scala/pull/4919">#4919</a>).</li>
  <li>We emit parameter names according to <a href="https://openjdk.java.net/jeps/118">JEP-118</a>, which makes them available to Java tools and exposes them through Java reflection.</li>
</ul>

<h2 id="breaking-changes">Breaking changes</h2>

<h3 id="object-initialization-locks-and-lambdas">Object initialization locks and lambdas</h3>

<p>In Scala 2.11, the body of a lambda was in the <code class="language-plaintext highlighter-rouge">apply</code> method of the anonymous function class generated at compile time. The new lambda encoding in 2.12 lifts the lambda body into a method in the enclosing class. An invocation of the lambda therefore involves the enclosing class, which can cause deadlocks that did not happen before.</p>

<p>For example, the following code</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import scala.concurrent._
import scala.concurrent.duration._
import ExecutionContext.Implicits.global
object O { Await.result(Future(1), 5.seconds) }
</code></pre></div></div>

<p>compiles to (simplified):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public final class O$ {
  public static O$ MODULE$;
  public static final int $anonfun$new$1() { return 1; }
  public static { new O$(); }
  private O$() {
    MODULE$ = this;
    Await.result(Future.apply(LambdaMetaFactory(Function0, $anonfun$new$1)), DurationInt(5).seconds);
  }
}
</code></pre></div></div>

<p>Accessing <code class="language-plaintext highlighter-rouge">O</code> for the first time initializes the <code class="language-plaintext highlighter-rouge">O$</code> class and executes the static initializer (which invokes the instance constructor). Class initialization is guarded by an initialization lock (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5">Chapter 5.5 in the JVM specification</a>).</p>

<p>The main thread locks class initialization and spawns the Future. The Future, executed on a different thread, attempts to execute the static lambda body method <code class="language-plaintext highlighter-rouge">$anonfun$new$1</code>, which also requires initialization of the class <code class="language-plaintext highlighter-rouge">O$</code>. Because initialization is locked by the main thread, the thread running the future will block. In the meantime, the main thread continues to run <code class="language-plaintext highlighter-rouge">Await.result</code>, which will block until the future completes, causing the deadlock.</p>

<p>One example of this <a href="https://github.com/rickynils/scalacheck/issues/290">surprised the authors of ScalaCheck</a> – now <a href="https://github.com/rickynils/scalacheck/pull/294">fixed</a> in version 1.13.4.</p>

<h3 id="lambdas-capturing-outer-instances">Lambdas capturing outer instances</h3>

<p>Because lambda bodies are emitted as methods in the enclosing class, a lambda can capture the outer instance in cases where this did not happen in 2.11. This can affect serialization.</p>

<p>The Scala compiler analyzes classes and methods to prevent unnecessary outer captures: unused outer parameters are removed from classes (<a href="https://github.com/scala/scala/pull/4652">#4652</a>), and methods not accessing any instance members are made static (<a href="https://github.com/scala/scala/pull/5099">#5099</a>). One known limitation is that the analysis is local to a class and does not cover subclasses.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class C {
  def f = () =&gt; {
    class A extends Serializable
    class B extends A
    serialize(new A)
  }
}
</code></pre></div></div>

<p>In this example, the classes <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> are first lifted into <code class="language-plaintext highlighter-rouge">C</code>. When flattening the classes to the package level, the <code class="language-plaintext highlighter-rouge">A</code> obtains an outer pointer to capture the <code class="language-plaintext highlighter-rouge">A</code> instance. Because <code class="language-plaintext highlighter-rouge">A</code> has a subclass <code class="language-plaintext highlighter-rouge">B</code>, the class-level analysis of <code class="language-plaintext highlighter-rouge">A</code> cannot conclude that the outer parameter is unused (it might be used in <code class="language-plaintext highlighter-rouge">B</code>).</p>

<p>Serializing the <code class="language-plaintext highlighter-rouge">A</code> instance attempts to serialize the outer field, which causes a <code class="language-plaintext highlighter-rouge">NotSerializableException: C</code>.</p>

<h3 id="sam-conversion-precedes-implicits">SAM conversion precedes implicits</h3>

<p>The <a href="https://www.scala-lang.org/files/archive/spec/2.12/06-expressions.html#sam-conversion">SAM conversion</a> built into the type system takes priority over implicit conversion of function types to SAM types. This can change the semantics of existing code relying on implicit conversion to SAM types:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trait MySam { def i(): Int }
implicit def convert(fun: () =&gt; Int): MySam = new MySam { def i() = 1 }
val sam1: MySam = () =&gt; 2 // Uses SAM conversion, not the implicit
sam1.i()                  // Returns 2
</code></pre></div></div>

<p>To retain the old behavior, your choices are:</p>

<ul>
  <li>compile under <code class="language-plaintext highlighter-rouge">-Xsource:2.11</code></li>
  <li>use an explicit call to the conversion method</li>
  <li>disqualify the type from being a SAM (e.g. by adding a second abstract method).</li>
</ul>

<p>Note that SAM conversion only applies to lambda expressions, not to arbitrary expressions with Scala <code class="language-plaintext highlighter-rouge">FunctionN</code> types:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val fun = () =&gt; 2     // Type Function0[Int]
val sam2: MySam = fun // Uses implicit conversion
sam2.i()              // Returns 1
</code></pre></div></div>

<h3 id="sam-conversion-in-overloading-resolution">SAM conversion in overloading resolution</h3>

<p>In order to improve source compatibility, overloading resolution has been adapted to prefer methods with <code class="language-plaintext highlighter-rouge">Function</code>-typed arguments over methods with parameters of SAM types. The following example is identical in Scala 2.11 and 2.12:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; object T {
     |   def m(f: () =&gt; Unit) = 0
     |   def m(r: Runnable) = 1
     | }

scala&gt; val f = () =&gt; ()

scala&gt; T.m(f)
res0: Int = 0
</code></pre></div></div>

<p>In Scala 2.11, the first alternative was chosen because it is the only applicable method. In Scala 2.12, both methods are applicable, therefore <a href="https://www.scala-lang.org/files/archive/spec/2.12/06-expressions.html#overloading-resolution">overloading resolution</a> needs to pick the most specific alternative. The specification for <a href="https://www.scala-lang.org/files/archive/spec/2.12/03-types.html#compatibility">type compatibility</a> has been updated to consider SAM conversion, so that the first alternative is more specific.</p>

<p>Note that SAM conversion in overloading resolution is always considered, also if the argument expression is not a function literal (like in the example). This is unlike SAM conversions of expressions themselves; see the previous section. See also the discussion in <a href="https://github.com/scala/scala-dev/issues/158">scala-dev#158</a>.</p>

<p>While the adjustment to overloading resolution improves compatibility overall, code does exist that compiles in 2.11 but is ambiguous in 2.12, for example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; object T {
     |   def m(f: () =&gt; Unit, o: Object) = 0
     |   def m(r: Runnable, s: String) = 1
     | }
defined object T

scala&gt; T.m(() =&gt; (), "")
&lt;console&gt;:13: error: ambiguous reference to overloaded definition
</code></pre></div></div>

<h3 id="inferred-types-for-fields">Inferred types for fields</h3>

<p>Type inference for <code class="language-plaintext highlighter-rouge">val</code>, and <code class="language-plaintext highlighter-rouge">lazy val</code> has been aligned with <code class="language-plaintext highlighter-rouge">def</code>, fixing assorted corner cases and inconsistencies (<a href="https://github.com/scala/scala/pull/5141">#5141</a> and <a href="https://github.com/scala/scala/pull/5294">#5294</a>). Concretely, when computing the type of an overriding field, the type of the overridden field is used as the expected type. As a result, the inferred type of a <code class="language-plaintext highlighter-rouge">val</code> or <code class="language-plaintext highlighter-rouge">lazy val</code> may change in Scala 2.12.</p>

<p>In particular, an <code class="language-plaintext highlighter-rouge">implicit val</code> that did not need an explicitly declared type in 2.11 may need one now. (Type-annotating implicits is always good practice anyway.)</p>

<p>You can get the old behavior with <code class="language-plaintext highlighter-rouge">-Xsource:2.11</code>. This may be useful for testing whether these changes are responsible if your code fails to compile.</p>

<h3 id="changed-syntax-trees-affects-macro-and-compiler-plugin-authors">Changed syntax trees (affects macro and compiler plugin authors)</h3>

<p>PR <a href="https://github.com/scala/scala/pull/4749">#4794</a> changed the syntax trees for selections of statically accessible symbols. For example, a selection of <code class="language-plaintext highlighter-rouge">Predef</code> no longer has the shape <code class="language-plaintext highlighter-rouge">q"scala.this.Predef"</code> but simply <code class="language-plaintext highlighter-rouge">q"scala.Predef"</code>. Macros and compiler plugins matching on the old tree shape need to be adjusted.</p>

<h2 id="improving-these-notes">Improving these notes</h2>

<p>Improvements to these release notes <a href="https://github.com/scala/make-release-notes/blob/2.12.x/hand-written.md">are welcome!</a></p>

<h2 id="conclusion">Conclusion</h2>

<p>We again thank our contributors and the entire Scala community. May you find Scala 2.12 a pleasure to code in.</p>

				</div>
			</div>
			<!-- TOC -->
			
<div class="content-nav">
	<div class="inner-box sidebar-toc-wrapper" style="">
		<h5>Contents</h5>
		<div class="inner-toc" id="sidebar-toc">

		</div>
		<hr>
		<div class="help-us"><a href="https://github.com/scala/scala-lang/blob/master/_posts/2016-11-03-release-notes-2.12.0.md" data-proofer-ignore><i class="fa fa-pencil" aria-hidden="true"></i> Problem with this page?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Please help us fix it!</a></div>
	</div>
</div>


		</div>
	</div>
</section>


</main>

<footer id="site-footer">
    <div class="wrap">
      <div class="site-footer-top">
        
          <ul class="documentation">
            <li><h3>Documentation</h3></li>
            
              
                <li><a href="https://docs.scala-lang.org/getting-started.html">Getting Started</a></li>
              
            
              
                <li><a href="https://www.scala-lang.org/api/current/index.html">API</a></li>
              
            
              
                <li><a href="https://docs.scala-lang.org/overviews">Overviews/Guides</a></li>
              
            
              
                <li><a href="https://scala-lang.org/files/archive/spec/2.13/">Language Specification</a></li>
              
            
          </ul>
        
          <ul class="download">
            <li><h3>Download</h3></li>
            
              
                <li><a href="/download/">Current Version</a></li>
              
            
              
                <li><a href="/download/all.html">All versions</a></li>
              
            
          </ul>
        
          <ul class="community">
            <li><h3>Community</h3></li>
            
              
                <li><a href="/community/">Community</a></li>
              
            
              
                <li><a href="/community/index.html#forums">Forums</a></li>
              
            
              
                <li><a href="/community/index.html#chat-rooms">Chat</a></li>
              
            
              
                <li><a href="/community/index.html#community-libraries-and-tools">Libraries and Tools</a></li>
              
            
              
                <li><a href="https://scala.epfl.ch/">The Scala Center</a></li>
              
            
          </ul>
        
          <ul class="contribute">
            <li><h3>Contribute</h3></li>
            
              
                <li><a href="/contribute/">How to help</a></li>
              
            
              
                <li><a href="/contribute/bug-reporting-guide.html">Report an Issue</a></li>
              
            
          </ul>
        
          <ul class="scala">
            <li><h3>Scala</h3></li>
            
              
                <li><a href="/blog/">Blog</a></li>
              
            
              
                <li><a href="/conduct.html">Code of Conduct</a></li>
              
            
              
                <li><a href="/license/">License</a></li>
              
            
          </ul>
        
          <ul class="social">
            <li><h3>Social</h3></li>
            
              
                <li><a href="https://github.com/scala">GitHub</a></li>
              
            
              
                 <!-- special case Manstodon to validate with rel="me" -->
                <li><a rel="me" href="https://fosstodon.org/@scala_lang">Mastodon</a></li>
              
            
              
                <li><a href="https://twitter.com/scala_lang">Twitter</a></li>
              
            
              
                <li><a href="https://discord.com/invite/scala">Discord</a></li>
              
            
              
                <li><a href="https://www.linkedin.com/company/scala-center/">LinkedIn</a></li>
              
            
          </ul>
        
      </div>
      <div class="site-footer-bottom">
        <p>Copyright © 2002-2023 École Polytechnique Fédérale <br>Lausanne (EPFL) Lausanne, Switzerland</p>
        <img src="/resources/img/frontpage/scala-logo-white.png" alt="">
      </div>
    </div>
  </footer>

    <!-- jquery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    <script src="/resources/js/vendor/jquery.autocomplete.js" type="text/javascript" ></script>

    <!-- tweet feed -->
    <script src="/resources/js/tweetMachine-update.js" type="text/javascript" ></script>

    <!-- prettify js -->
    <script src="/resources/js/vendor/prettify/prettify.js" type="text/javascript" ></script>
    <script src="/resources/js/vendor/prettify/lang-scala.js" type="text/javascript" ></script>

    <!-- unslider js -->
    <script src="/resources/js/vendor/unslider.js" type="text/javascript" ></script>

    <!-- Highlight -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js" type="text/javascript"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/languages/scala.min.js" type="text/javascript"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/languages/java.min.js" type="text/javascript"></script>

    <!-- Custom Syntax Highlight -->
    <script src="/resources/js/hljs-scala3.js" type="text/javascript"></script>

    <!-- CodeMirror -->
    <script src="/resources/js/vendor/codemirror/codemirror.js" type="text/javascript"></script>
    <script src="/resources/js/vendor/codemirror/clike.js" type="text/javascript"></script>

    <!-- TOC -->
    
      <script src="/resources/js/vendor/jquery.sticky.js" type="text/javascript" ></script>
      <script src="/resources/js/vendor/toc.js" type="text/javascript" ></script>
    

    <!-- Blog search -->
    <script src="/resources/js/vendor/jekyll.search.min.js" type="text/javascript"></script>

    <!-- Custom javascript -->
    <script src="/resources/js/functions.js" type="text/javascript"></script>
    <script defer data-domain="scala-lang.org" src="https://plausible.scala-lang.org/js/script.js"></script>
  </body>
</html>
